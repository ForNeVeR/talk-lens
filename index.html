<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport"
              content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Как мы разработали свой язык программирования</title>

        <link rel="stylesheet" href="node_modules/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="node_modules/reveal.js/css/theme/white.css">
        <link rel="stylesheet" href="node_modules/reveal.js/lib/css/zenburn.css">
        <style>
            img {
                border: 0 !important;
                box-shadow: none !important;
                max-height: 500px !important;
            }
            body > .reveal > .slide-number {
                left: 8px;
                right: initial;
                font-size: 6vh;
            }
            .reveal pre code.hljs {
                max-height: 500px;
            }
            .reveal blockquote p {
                text-align: left;
            }
            .reveal h2 {
                text-transform: initial;
            }
            .reveal ol {
                font-size: 85%;
            }
            .reveal section img {
                background: none;
            }
            .reveal .first-slide h2 {
                color: #fff;
                font-size: 1.3em;
                text-align: left;
                margin-top: -1em;
            }
            .reveal .first-slide .speaker {
                color: #fff;
                text-align: left;
                position: relative;
                top: 1em;
            }
            .first-slide > .title-section {
                max-width: 60%;
                position: relative;
                right: 0;
                top: 0;
                text-align: right;
                margin-left: auto;
            }
            .jb-logo {
                width: 5em;
                height: 5em;
                top: -1em;
                right: 4em;
                position: relative;
            }
        </style>
    </head>
    <body>
        <div class="reveal" data-separator-notes="^Notes:">
            <div class="slides">
                <section>
                    <section data-background="images/background.png" class="first-slide">
                        <div class="title-section">
                            <img src="images/jetbrains.png" class="jb-logo" />
                            <h2>Как разработать собственный язык программирования на&nbsp;примере LENS<br/>—</h2>
                            <div class="speaker">
                                █████████ von █████
                            </span>
                        </div>
                    </section>
                    <section>
                        <h2>☭ Maintenance section ☭</h2>
                        <ul>
                            <li><a href="#" onclick="javascript:window.location.hash = 'show-notes';window.location.reload();return false;">Show slide notes</a></li>
                            <li><a href="#" onclick="javascript:window.location.search = 'print-pdf';return false;">Enter PDF mode</a></li>
                        </ul>
                    </section>
                </section>
                <section data-markdown>
                    ![](images/github.png)

                    https://github.com/impworks/lens
                    Notes:

                    Однажды нам с товарищем (вот он) стало очень скучно, и мы решили взять и
                    написать свой язык программирования. В тот раз нам повезло, и _остановить нас
                    было некому_, поэтому мы успешно эту задачу решили!

                    Почти каждый программист хоть раз в жизни задумывается о том, что неплохо бы
                    создать свой язык программирования. Мотивация у людей разная: кому-то не
                    дают покоя лавры создателей уже известных языков, кто-то жаждет исправить
                    все-все фатальные недостатки в том языке, на котором пишет сейчас, а кто-то,
                    как мы, просто хочет немного повеселиться.

                    Однако разработка языка — это не только веселье. Я могу сказать, что
                    разработка собственного языка позволила мне изучить очень много полезного
                    про устройство платформы, с которой я работаю, и благодаря этому опыту я
                    значительно лучше понимаю логику других компиляторов, с которыми мне
                    приходится работать.

                    Даже если написанный вам язык вам самим в будущем не пригодится, полученные
                    знания точно останутся с вами.
                </section>
                <section data-markdown>
                    ## Базовый синтаксис

                    ```fsharp
                    using System.Drawing

                    pure fun dist:double (p1:Point p2:Point) ->
                        let x = p1.X - p2.X
                        let y = p1.Y - p2.Y
                        Math::Sqrt (x ** 2 + y ** 2)

                    let pA = new Point 1 2
                    let pB = new Point 10 20
                    print "The distance is: {0}" (dist pA pB)
                    ```

                    Notes:

                    Язык, который мы разработали, называется **LENS**: Language for Embeddable
                    .NET Scripting. Это статически типзиированный язык программирования с
                    ограниченным выводом типов, который компилируется в байт-код платформы .NET.

                    Как видите, выглядит достаточно нормально — как полноценный язык
                    программирования. И для его разработки не потребовалось слишком много усилий
                    — два совершенно обычных человека смогли его сделать примерно за полгода
                    неспешной работы.
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Функциональные возможности языка

                        ```fsharp
                        record Store
                            Name : string
                            Stock : int

                        fun desribe:string (arr:object[]) ->
                          match arr with
                            case [] then "empty array"
                            case [x:int] when x < 10 then
                              fmt "array with 1 small int ({0})" x
                            case [x] then "array with 1 item"
                            case [x; y] then "array with 2 items"
                            case [x; y; ...z] then
                              fmt "array with {0}, {1} and {2} more" x y z.Length
                        ```

                        Notes:

                        В целом синтаксис похож на язык F#, и в нём есть пара интересных
                        возможностей типа pattern matching (местами даже получше F#'ового) и record
                        types, но в основном язык просто поддерживает всё, что можно ожидать от
                        обычного языка под .NET: классы, структуры, функции, методы и прочее. Я
                        сегодня не буду особенно подробно останавливаться на особенностях самого
                        языка, а постараюсь рассказать о разработке языков программирования в целом,
                        фокусируясь на платформах типа .NET или Java Virtual Machine.
                    </script>
                </section>
                <section data-markdown>
                    ## Общее устройство компилятора

                    ![](images/compiler.svg)

                    Notes:

                    Компилятор с высоты птичьего полёта выглядит примерно так. Это такая коробочка,
                    на входе у которой исходный код программы, а на выходе — некое итоговое
                    представление этой программы, исполняемый файл.

                    Между ними находятся этапы лексического и синтаксического разбора (которые
                    иногда объединяют) и транслятор.

                    Сначала ваш исходный текст проходит обработку _лексером_ и превращается в поток
                    неких специальных токенов, затем _парсер_ строит синтаксическое дерево, а затем
                    транслятор превращает это дерево в бинарный файл.
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Расширенная форма Бэкуса-Наура (EBNF)

                        ```ebnf
                        (* специальное регулярное выражение *)
                        identifier = ? [a-zA-Z_][0-9a-zA-Z_]* ? ;
                        ```
                        <!-- .element: class="fragment" -->

                        ```ebnf
                        (* следование символов друг за другом, литералы *)
                        ab = "a", "b" ;
                        ```
                        <!-- .element: class="fragment" -->

                        ```ebnf
                        (* опциональные символы, последовательности *)
                        maybe_a = [ a ], { ".", "b" } ;
                        ```
                        <!-- .element: class="fragment" -->

                        ```ebnf
                        (* ветвление *)
                        a_or_b_or_c = a | b | c ;
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        Итак, любой язык программирования начинается, разумеется, с синтаксиса. Чаще
                        всего у авторов языка есть какие-то претензии к синтаксису других языков
                        (слишком много скобочек, слишком мало скобочек, хочется отступы, не хочется
                        отступов), и свои фантазии они реализуют в виде синтаксиса, приятного их
                        глазу.

                        Для формального описания грамматики языка часто используют расширенную
                        нотацию Бэкуса-Наура (EBNF). Она позволяет определить ряд правил для того,
                        чтобы описать всё, что есть в нашем языке.

                        Во-первых, если некоторые части синтаксиса мы не можем или не хотим
                        определять формально, можно использовать расширение нотации: внутри знаков
                        вопроса можно делать любые записи (подразумевается, что они дальше будут
                        как-то обработаны вместе с нотацией). Например, несмотря на то, что
                        официально EBNF не даёт возможности описывать грамматику с помощью
                        регулярных выражений, мы можем в своей грамматике всё равно использовать
                        такой синтаксис — и потом, конечно, предусмотреть его, когда мы будем
                        реализовывать разбор в соответствии с грамматикой.

                        Во-вторых, грамматика позволяет определить литералы — это текстовые
                        последовательности, которые должны буквально встретиться в документе,
                        соответствующем грамматике. Через запятую можно описывать последовательность
                        нескольких элементов.

                        В-третьих, есть специальный синтаксис для опциональных элементов (которые
                        могут присутствовать или отсутствовать) и для последовательностей элементов.

                        Для случаев, когда в синтаксисе должен присутствовать один из нескольких
                        возможных элементов, используется ветвление.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Часть грамматики LENS в нотации EBNF

                        ```ebnf
                        identifier = ? [a-zA-Z_][0-9a-zA-Z_]* ? ;
                        for = "for", identifier, "in", line_expr, [ ".." line_expr ], "do",
                            INDENT, code_block ;
                        line_expr = if_line | while_line | for_line … ;
                        ```

                        ```fsharp
                        for x in 1 .. (2 * 2) do
                            print x
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        Вот пример небольшой части синтаксиса LENS в форме EBNF. Например, выражение
                        цикла `for` состоит из ключевого слова `for`, идентификатора, ключевого
                        слова `in`, описателя выражения (опционально за которым следует описатель
                        конца цикла), затем ключевое слово `do`, увеличение уровня отступа и блок
                        кода.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ![](images/programming-language.01.svg)

                        <div class="fragment">

                            `a = b + 2`

                            ![](images/ast.svg)
                        </div>

                        Notes:

                        Соответственно, первой задачей, которая решается при разработке языка,
                        является создание механизма по разбору исходного кода. На входе у него текст
                        программы, а на выходе — абстрактное синтаксическое дерево. Это дерево,
                        описывающее структуру исходного кода, но уже не в текстовом виде, а в
                        представлении, которым удобно оперировать дальше.

                        Например, если у нас есть какое-то простое выражение типа `a = b + 2`, его
                        абстрактное синтаксическое дерево будет выглядеть примерно так: есть узел с
                        операцией присваивания, с левой стороны у которого стоит узел с переменной
                        `a`, а с правой — узел операции сложения переменной `b` и числа `2`.

                        Весь исходный файл программы собирается в такое дерево, и потом уже
                        обрабатывается дальше.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Генераторы парсеров

                        (например, ANTLR)

                        ```java
                        atomExp returns [double value]
                            : n=Number {$value = Double.parseDouble($n.text);}
                            | i=Identifier {$value = memory.get($i.text);}
                            | '(' exp=additionExp ')' {$value = $exp.value;}
                            ; // https://stackoverflow.com/a/2042467/2684760
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        К автоматизированному написанию парсера для языка программирования есть два
                        основных подхода. Первый подход — это генераторы парсеров.

                        Генераторы парсеров — это специальные программы, которые позволяют с помощью
                        нотации, похожей на BNF, сгенерировать код, который будет разбирать
                        интересующий вас синтаксис. То есть генератору парсеров можно скормить
                        практически в неизменном виде нотацию, которую мы видели ранее, и, если она
                        построена корректно, он сгенерирует нам разборщик кода программы.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Комбинаторы парсеров

                        (parsec, fparsec & co)

                        ```ebnf
                        if_expr = "if" "(" line_expr ")" block [ "else" block ]
                        ```
                        <!-- .element: class="fragment" -->

                        ```fsharp
                        if_exprRef := pipe3
                            <| (keyword "if" >>.
                                (between <| token "(" <| token ")" <| line_expr))
                            <| block
                            <| opt (keyword "else" >>. block)
                            <| Node.ifNode
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        При разработке языка нам, однако, не захотелось иметь дело со
                        сгенерированными исходниками и усложнением процесса сборки нашего будущего
                        компилятора, и поэтому мы пошли вторым путём: использовали библиотеку
                        комбинаторов парсеров.

                        Одна из самых крутых подобных библиотек сегодня написана на Haskell и
                        называется parsec, но её портировали и на многие другие языки. В частности,
                        для языка программирования F# существует вариант fparsec, который мы и
                        использовали изначально для разбора кода.

                        Поскольку F# позволяет определять свои операторы, получившаяся нотация
                        довольно похожа на исходную BNF, хотя и не всегда ложится на неё
                        один-к-одному.

                        Для примера давайте рассмотрим, как вот эта EBNF-нотация будет выглядеть в
                        синтаксисе fparsec.
                    </script>
                </section>
                <section data-markdown>
                    ## Parser Story Time

                    ![](images/story-time.jpg)

                    Notes:

                    Настало время занимательных историй про парсеры. Поскольку разработкой первой
                    итерации парсера в основном занимался я, то у меня их достаточно. При написании
                    парсера мы столкнулись с несколькими проблемами.
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Отступы в синтаксисе

                        ```ebnf
                        block = NL, block_line, { block_line } ;
                        block_line = INDENT (???), expression, NL ;
                        ```

                        ```ebnf
                        block = INDENT, expression, { NL expression }, DEDENT ;
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        Во-первых, было непросто поддержать язык, основанный на отступах даже на
                        уровне грамматики. Изначально вообще было не очень понятно, как это сделать.
                        Вот пример грамматики. В ней указано, что блок кода — это последовательность
                        строк. А каждая строка — это отступ + выражение. И тут уже становится
                        непонятно, что такое отступ — в грамматике нет требования, что у всех строк
                        в блоке кода отступ одинаковый. Получается, это требование нужно указывать
                        отдельно. И как такое требование обрабатывать в fparsec — непонятно. Мы
                        написали по почте автору библиотеки, и он дал нам пару очень ценных советов,
                        которые помогли продвинуться в этом вопросе.


                        В итоге `INDENT` превратился в синтетический токен, который в грамматике
                        обозначает не сам отступ, а увеличение уровня отступа на единицу. И появился
                        токен `DEDENT`, который обозначает уменьшение уровня отступа.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Сообщения об ошибках

                        ```fsharp
                        // неправильно
                        if a = 3
                            print a

                        // правильно
                        if (a = 3)
                            print a
                        ```

                        ```fsharp
                        let debug = true
                        let (<!>) (p : Parser<_,_>) label : Parser<_,_> =
                            if debug then
                                fun stream ->
                                    printfn "%A: Entering %s" stream.Position label
                                    let reply = p stream
                                    printfn "%A: Leaving %s (%A)"
                                        stream.Position label reply.Status
                                    reply
                            else
                                p
                        ```
                        <!-- .element: class="fragment" -->

                        Notes:

                        Для нас было важно, чтобы сообщения об ошибках были читаемыми (потому что
                        читали их в первую очередь мы сами при разработке парсера и грамматики). Но
                        при этом наш парсер никак не мог их начать нормально генерировать. Дело в
                        том, что парсер для нашего языка работал по механизму т. н. парсеров с
                        откатом: если он видел какое-то выражение, похожее на `if` или `for`, то
                        начинал его разбирать в соответствии с этими синтаксическими узлами. Если
                        вдруг где-то в середине разбора у него не получалось дальше искать элементы
                        соответствующего узла (например, пользователь забыл скобку у выражения `if`)
                        — он «откатывался» к началу выражения и пробовал другие варианты — ну, мало
                        ли, вдруг это пользователь свою функцию решил назвать `if`, или ещё что-то в
                        этом роде.

                        На больших масштабах этот механизм стал работать не очень предсказуемо:
                        зачастую парсер, увидев некорректные узлы (например, недописанную
                        программу), просто откатывался к самому началу текста и говорил, что
                        программа не является корректной и завершённой. **Вся программа**, без
                        подсказок. В таких случаях нам приходилось подолгу сидеть над логами
                        парсера, чтобы понять, что и как он пробовал разобрать, и почему у него не
                        получилось.

                        Была написана функция с непроизносимым названием `<!>`, которая, если
                        включен отладочный режим, при входе в режим разбора любого узла
                        синтаксического дерева записывала этот факт в лог.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ![](images/logs.gif)

                        Notes:

                        Через какое-то время мне надоело читать по 600 киБ логов на каждый мелкий
                        баг парсера (на гифке: 30 киБ логов, чтобы распарсить выражение
                        `print 123`), и мы решили его переписать на C#, без использования библиотек.
                        Это позволило нам сделать сообщения об ошибках более человечными и решило
                        проблему с парсингом. Некоторые другие профессиональные компиляторы тоже
                        используют такой подход, но, возможно, нам просто стоило с самого начала
                        использовать генератор парсеров, а не библиотеку комбинаторов ☺
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## LISP

                        ```lisp
                        (defun test-let ()
                          (System.Console.Write "Let: ")
                          (let ((ok "OK"))
                            (System.Console.WriteLine ok)))
                        (System.Console.WriteLine "Naggum test suite")

                        (let ((thread (System.Threading.Thread.get_CurrentThread))
                              (culture
                                (System.Globalization.CultureInfo.get_InvariantCulture)))
                            (System.Console.WriteLine "Setting up an environment...")
                            (call set_CurrentCulture thread culture))

                        (test-let)
                        ```

                        Notes:

                        Поэтому вот вам совет от бывалого разработчика парсеров: если хотите
                        написать свой язык — не заморачивайтесь. Напишите лисп :)
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ![](images/programming-language.02.svg)

                        Notes:

                        Следующим этапом, через который проходит абстрактное синтаксическое
                        дерево вашего языка, является компиляция. Если говорить о языках
                        программирования вообще, то бывают, разумеется, и интерпретируемые
                        языки, и на данном этапе уже можно их интерпретировать. Но мы занимались
                        разработкой строго типизированного компилируемого языка с ограниченным
                        выводом типов, поэтому именно об этом я и буду рассказывать.

                        Мы для своего компилятора выбрали целевую платформу .NET, поскольку оба
                        автора являлись (и до сих пор являются) программистами именно под неё. Но на
                        самом деле можно писать компиляторы и под чужие целевые платформы —
                        например, на C++ написать компилятор в Java-байт код.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Машинный код (x86, x86-64, ARM, etc.)

                        ```fsharp
                        _+C..ctor()
                            L0000: cmp [ecx], al
                            L0002: ret

                        ; return x * y + z
                        _+C.MulAdd(Int32, Int32, Int32)
                            L0000: mov eax, [esp+0x8]
                            L0004: imul eax, edx
                            L0007: add eax, [esp+0x4]
                            L000b: ret 0x8
                        ```
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## LLVM (Low Level Virtual Machine)

                        ```fsharp
                        ; http://releases.llvm.org/2.6/docs/tutorial/JITTutorial1.html

                        define i32 @mul_add(i32 %x, i32 %y, i32 %z) {
                            entry:
                              %tmp = mul i32 %x, %y
                              %tmp2 = add i32 %tmp, %z
                              ret i32 %tmp2
                            }
                        ```

                        Rust, Swift, Kotlin/Native
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## CIL (.NET)

                        ```fsharp
                        .method public hidebysig
                            instance int32 MulAdd (
                                int32 x,
                                int32 y,
                                int32 z ) cil managed  {
                            .maxstack 8

                            IL_0000: ldarg.1
                            IL_0001: ldarg.2
                            IL_0002: mul
                            IL_0003: ldarg.3
                            IL_0004: add
                            IL_0005: ret }
                        ```

                        C#, F#, VB.NET etc.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## JavaScript

                        ```javascript
                        var a = +$("#input1")[0].value;
                        var b = +$("#input2")[0].value;
                        var c = +$("#input3")[0].value;

                        $("#output")[0].value = a * b + c;
                        ```

                        TypeScript, Flow, Scala.js, Kotlin/JS
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Frege

                        https://github.com/Frege/frege

                        ```haskell
                        module Hello where

                        greeting friend = "Hello, " ++ friend ++ "!"

                        main args = do
                            println (greeting "World")
                        ```
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Frege → Java

                        ```java
                        final public static Func.U<RealWorld, Short> $main(final Lazy<PreludeBase.TList<String/*<Character>*/>> arg$1) {
                            return Prelude.<String/*<Character>*/>println(PreludeText.IShow_String.it, Hello.greeting("World"));
                          }

                            public static void main(final java.lang.String[] argv) {
                              try {
                                frege.run.RunTM.argv = argv;

                                  PreludeBase.TST.<Short>performUnsafe($main
                                         (Thunk.lazy(PreludeArrays.IListSource_JArray.<String/*<Character>*/>toList(argv))).call()
                                    ).call();
                                frege.runtime.Runtime.stdout.get().close();
                                frege.runtime.Runtime.stderr.get().close();

                              } finally { frege.run.Concurrent.shutDownIfExists(); }
                            }
                          }
                        ```
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ![](images/programming-language.03.svg)

                        Notes:

                        Тут следует заметить, что, выбирая целевую платформу, вы выбираете не
                        только какой-то байткод или промежуточное представление кода, а
                        выбираете целую экосистему. Со всеми инструментами: пакетными
                        менеджерами, средами разработки и пр. В какой-то мере вы даже выбираете
                        программистов, которые будут вашим языком пользоваться. Это очень важно,
                        и это нужно учитывать. По этой же причине непросто бывает работать сразу
                        с несколькими целевыми платформами: сложно на них всех поддержать
                        одинаковый пользовательский опыт и обеспечить портирование библиотек.
                        Даже одинаковую стандартную библиотеку на разных платформах получить
                        сложно.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Context

                        - опции компиляции
                        - генерация байт-кода
                        - стек областей видимости

                        - импортированные сборки и пространства имён
                        - доступные функции
                        - доступные поля и переменные
                        - ограничение на доступные сущности ("safe mode")

                        - стандартная библиотека
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ![](images/nodes.svg)

                        ```csharp
                        using (var x = Foo()) {
                        }
                        // expanded to:
                        var x = Foo();
                        try { } finally {
                            if (x != null) x.Dispose();
                        }
                        ```

                        Notes:

                        Архитектурно синтаксическое дерево представлено иерархией классов, базовый
                        класс называется `NodeBase`, и у него порядка 70 наследников.

                        Каждый узел синтаксического дерева знает, как себя компилировать в байткод.
                        Поэтому для того, чтобы скомпилировать блок кода, достаточно позвать методы
                        компиляции у всех узлов синтаксического дерева, которые формируют этот блок.
                        Для этого у узлов дерева есть метод `Emit`.

                        Также в языке был применён один интересный подход, отдалённо похожий на
                        макросы. Некоторые узлы дерева (например, узел `using`) не генерируют
                        байткод самостоятельно, а просто сами себя преобразуют в другие узлы. Таким
                        образом, увеличение количества синтаксического сахара в языке не приводит к
                        очень уж большому разрастанию генератора кода.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## CLI — Common Language Infrastructure (.NET)

                        ![](images/byte-code.svg)

                        Notes:

                        Теперь мы поговорим про то, как вообще работает виртуальная машина, и что за
                        байткод такой.

                        У виртуальной машины .NET, как и у JVM, есть спецификация, которая описывает
                        архитектуру и стандартный набор инструкций. Виртуальная машина, в отличие от
                        настоящих процессоров, является стековой: это значит, что для того, чтобы
                        что-то делать с данными, вы можете оперировать только со стеком и другими
                        видами локальной памяти, никаких регистров тут нет.

                        Байт-код является достаточно высокоуровневым: он знает про классы, методы,
                        генерики и всю систему типов .NET. Для байт-кода есть свой своеобразный
                        высокоуровневый ассемблер, на котором можно (и даже несложно) писать
                        полноценные программы. Я не могу с уверенностью сказать, что знаю людей,
                        которые пишут на этом ассемблере большие программы, но я точно знаю людей,
                        которые __говорят__, что пишут на этом ассемблере большие программы.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## JIT-компилятор (Just-In-Time)

                        ![](images/jit.svg)

                        Notes:

                        Некоторые виртуальные машины (например, Java Virtual Machine) умеют
                        интерпретировать байт-код, но .NET так не делает, а сразу компилирует его в
                        машинное представление. Этим занимается специальная часть виртуальной
                        машины: JIT (Just-In-Time Compiler).
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Динамическая генерация байт-кода

                        ```csharp
                        for (int i = 0; i < code.Length; ++i) {
                          switch (code[i]) {
                            case '+':
                              ilGenerator.Emit(OpCodes.Ldloc_0);
                              ilGenerator.EmitCall(OpCodes.Call, GetMethod("Add"), null);
                              break;
                            case '-':
                              ilGenerator.Emit(OpCodes.Ldloc_0);
                              ilGenerator.EmitCall(OpCodes.Call, GetMethod("Dec"), null);
                              break;
                            case '>': // …
                            case '<': // …
                            case '.': // …
                            case ',': // …
                            case '[': // …
                            case ']': // …
                        ```

                        Notes:

                        Для того, чтобы сгенерировать байт-код во время выполнения программы, а
                        потом с ним что-то сделать (например, исполнить или сохранить на диск), в
                        CLI есть специальный механизм: он называется `Reflection.Emit`. С помощью
                        этого механизма мы генерируем типы, методы и потоки инструкций для каждого
                        метода. Выглядит это очень просто: каждой инструкции байт-кода соответствует
                        вызов метода специального класса `ILGenerator`.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Reflection.Emit

                        Достоинства:
                        - можно сгенерировать и сразу выполнить байт-код
                        - можно сохранить код в EXE или DLL

                        Недостатки:
                        - не работает кросскомпиляция
                        - библиотеки в адресном пространстве компилятора
                        - можно решить Mono.Cecil

                        Notes:

                        После компиляции код можно сразу начинать выполнять, даже не сохраняя его на
                        диск. Ну или можно сохранить, чтобы выполнить в дальшейшем.

                        Есть у такого подхода и недостатки: поскольку мы генерируем код в рамках
                        текущего процесса, то мы должны в процесс компилятора загружать все
                        библиотеки, которые нам нужны для работы конечной программы, а также мы не
                        можем генерировать код для другого варианта виртуальной машины (например,
                        для .NET Core).

                        Если хочется эти недостатки решить, можно использовать другие технологии
                        генерации байт-кода — например, библиотеку Mono.Cecil, которая позволяет
                        работать с байт-кодом, не подгружая его в контекст текущего процесса.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Embeddable Scripting

                        ```csharp
                        double x = 5, y = 10, res = 10;
                        var cp = new LensCompiler();
                        cp.RegisterProperty("x", () => x);
                        cp.RegisterProperty("y", () => y);
                        cp.RegisterProperty("res",
                            () => res,
                            r => res = r);

                        var source = "res = x * y + res";
                        var compiled = cp.Compile(source);
                        compiled.Run(); // res = 60
                        ```

                        Notes:

                        LENS расшифровывается как Language for Embeddable .NET Scripting. Это
                        подразумевает, что наш компилятор можно удобно встроить в уже имеющуюся
                        программу и использовать его для скриптования.

                        Примерно вот так выглядит API для загрузки и использования компилятора:
                        очень несложно. Этот пример сгенерирует в памяти исполняемую сборку с телом
                        метода `res = x * y`, а потом тут же выполнит этот код. Можно задавать
                        окружение для кода — это нужно для того, чтобы он мог обращаться к каким-то
                        переменным или функциям хостовой программы.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Зачем нужны скрипты?

                        ![](images/tea-scheme.svg)
                        <!-- .element: class="fragment" -->

                        Notes:

                        Обычно с open-source проектами у меня получается так, что я их пишу и они
                        мне не пригождаются. Это связано с самим процессом разработки. Я могу начать
                        делать какой-то язык или библиотеку в ответ на появление некой проблемы. Но
                        разработка языка или библиотеки — процесс небыстрый, и очень часто бывает,
                        что к моменту завершения разработки проблема уже сама собой разрешилась
                        каким-то иным способом.

                        Но тут перед нами предстаёт совершенно анекдотическая ситуация: мы
                        разработали язык программирования, а он взял и пригодился ☺

                        Во время научной работы я разработал программу, которая формировала
                        различные варианты представления для некоторых экспериментальных данных.
                        Схема работы с программой выглядела так: нажать на кнопку, подождать 20
                        минут, потом нажать на вторую кнопку, ещё 20 минут — и так в цикле, пока не
                        достигнут некоторый экспериментальный результат. Нажимать на кнопки раз в 20
                        минут было довольно скучно, и поэтому я решил приделать к своей научной
                        программе сприптовой язык программирования. Пользователь-учёный теперь может
                        написать скрипт на LENS и загрузить его в программу, а после этого спокойно
                        уходить на несколько часов, пока она будет сама нажимать на кнопки и делать
                        работу.

                        На слайде вы видите код на LENS, который размещается внутри кода на F#. Была
                        написана, с позволения сказать, «стандартная библиотека», состоящая из
                        нескольких определений функций. Потом мы эту библиотеку «пришиваем» с
                        помощью конкатенации строк прямо к скрипту, и выполняем его.
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ```fsharp
                        planPath = "plans/microwave-plan-30-khz.xml"
                        new [
                            openems "Microwave: 30 kHz" 30000m "30-khz" "30-kHz.png"
                            openems "Microwave: 3 MHz" 3000000m "3-mhz" "3-MHz.png"
                            openems "Microwave: 50 MHz" 50000000m "50-mhz" "50-MHz.png"
                            openems "Microwave: 300 MHz" 300000000m "300-mhz" "300-MHz.png"
                            complex "Microwave: Complex" "Complex-all.png"
                        ]
                        ```
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ```fsharp
                        use lens = new LensCompiler()
                        let script = library + "\n\n" + File.ReadAllText(scriptPath)
                        let program = lens.Compile(script)
                        let steps = downcast program.Invoke()
                        ```
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Вот зачем нужны скрипты

                        ![](images/tea-scheme.2.svg)
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Выводы

                        1. Разработать свой язык программирования может каждый.
                        <!-- .element: class="fragment" -->
                        2. Бывает удобно базировать язык на существующей высокоуровневой виртуальной машине (CLI, JVM,
                           etc.).
                        <!-- .element: class="fragment" -->
                        3. Иногда вещи, которые кажутся бессмысленными, могут пригодиться.
                        <!-- .element: class="fragment" -->
                        4. …а иногда нет ☺
                        <!-- .element: class="fragment" -->
                        5. Рассмотрите возможность использовать синтаксис Lisp.
                        <!-- .element: class="fragment" -->
                        6. Делать свои языки программирования – полезно!
                        <!-- .element: class="fragment" -->
                    </script>
                </section>
                <section data-markdown class="center">
                    <script type="text/template">
                        ## Это конец.
                        <div style="width: 100%; text-align: left;">
                            <img src="images/the-end.svg" style="width: 35vw;"/>
                        </div>
                        <small class="fragment">
                            Материалы доклада доступны в репозитории:<br/>
                            https://github.com/ForNeVeR/talk-lens
                            <br/><br/>
                            Код LENS доступен в репозитории:<br/>
                            https://github.com/impworks/lens
                            <br/><br/>
                            Контакты автора:<br/>
                            █████████ von █████<br/>
                            <a href="mailto:friedrich@fornever.me">friedrich@fornever.me</a><br/>
                            https://t.me/fvnever
                        </small>
                    </script>
                </section>
            </div>
        </div>

        <script src="node_modules/reveal.js/lib/js/head.min.js"></script>
        <script src="node_modules/reveal.js/js/reveal.js"></script>

        <script>
            Reveal.initialize({
                dependencies: [
                    { src: 'node_modules/reveal.js/plugin/markdown/marked.js' },
                    { src: 'node_modules/reveal.js/plugin/markdown/markdown.js' },
                    { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true },
                    {
                        src: 'node_modules/reveal.js/plugin/highlight/highlight.js',
                        async: true,
                        callback: function() { hljs.initHighlightingOnLoad(); }
                    }
                ],
                showNotes: window.location.hash.match(/show-notes/gi),
            });
            Reveal.addEventListener('slidechanged', (event) => {
                const isFirst = event.indexh === 0;
                Reveal.configure({ slideNumber: !isFirst });
            });
        </script>
        <script>
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'node_modules/reveal.js/' + (
                window.location.search.match(/print-pdf/gi)
                    ? 'css/print/pdf.css'
                    : 'css/print/paper.css'
                );
            document.getElementsByTagName('head')[0].appendChild(link);
        </script>
    </body>
</html>
